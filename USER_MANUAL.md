# 游戏内存分析工具 - 用户手册

## 1. 简介

本工具是一款现代化的游戏内存分析与修改工具，旨在帮助安全研究员和游戏爱好者更高效地进行逆向工程。它围绕“**正向定位稳定锚点并解析结构**”的核心理念构建，通过强大的AOB扫描、结构化内存访问和自动化脚本，将繁琐的手动查找过程转变为可复用的自动化流程。

**核心功能**:
- **附加到进程**: 快速附加到目标游戏进程。
- **AOB扫描**: 使用字节序列（支持通配符）在整个进程空间或特定模块中查找代码和数据。
- **结构化内存分析**: 定义数据结构（如玩家、NPC），并以面向对象的方式访问内存，告别手动计算偏移量。
- **自动化脚本**: 编写Python脚本来自动完成地址的查找和解析，一劳永逸。
- **结构体编辑器**: 在图形界面中方便地创建、编辑和管理您的数据结构定义。
- **代码注入**: 将您自己的代码注入目标进程并执行，用于功能扩展或行为修改。

---

## 3. 功能详解

### 3.1 地址表

地址表是您进行内存分析的核心工作区。它显示了通过脚本或手动添加的内存地址的实时信息。

- **地址 (Address)**: 内存地址的十六进制表示。
- **标签 (Label)**: 您为该地址指定的有意义的名称（例如 `PlayerBase`, `GameManager`）。
- **类型 (Type)**: 该地址所指向数据的数据类型（例如 `int`, `float`, `string`, `Player*`）。如果是指针，星号 `*` 表示指针层级。
- **值 (Value)**: 从该地址读取到的当前值。对于结构体，会显示其成员的值。
- **操作**: 
    - **添加/删除行**: 手动添加或删除地址条目。
    - **从脚本加载**: 执行一个自动化脚本，并将其结果加载到地址表中。

### 3.2 AOB扫描器

AOB (Array of Bytes) 扫描器用于在内存中查找特定的字节序列，这对于定位不随程序重启而改变的静态代码或数据（我们称之为“锚点”）至关重要。

1.  在输入框中输入字节序列。使用 `?` 或 `??` 作为通配符。例如: `8B 0D ? ? ? ? 85 C9`。
2.  点击 `扫描` 按钮。
3.  扫描结果会显示在下方的列表中。双击一个结果可以将其地址复制到剪贴板。

### 3.3 结构体编辑器

结构体编辑器允许您以图形化的方式定义游戏中的数据结构，从而实现对内存的结构化访问。

1.  **添加结构体**: 点击 `添加结构体`，输入结构体名称（例如 `Player`）。
2.  **选择结构体**: 在左侧列表中选择您要编辑的结构体。
3.  **添加成员**: 点击 `添加成员`，在右侧表格中添加一行。
4.  **编辑成员**: 在表格中直接编辑成员的 `偏移量 (Offset)`, `名称 (Name)` 和 `类型 (Type)`。
    - **偏移量**: 相对于结构体基地址的字节偏移，可以是十进制或十六进制 (以`0x`开头)。
    - **名称**: 成员变量的名称 (例如 `health`, `mana`)。
    - **类型**: 成员的数据类型 (例如 `int`, `float`, `Vector3`)。
5.  **保存更改**: 点击 `保存更改` 将您的定义保存到 `definitions.yaml` 文件中，以便在脚本和地址表中重复使用。

### 3.4 自动化脚本

自动化是本工具的核心。您可以通过编写Python脚本来自动化整个地址查找过程。

- **脚本位置**: 脚本位于 `scripts/` 目录下。
- **核心对象**: 在脚本中，您可以使用一个预先配置好的 `scanner` 对象，它提供了所有必要的API（AOB扫描、内存读写等）。
- **返回值**: 脚本应该返回一个字典，其中键是您指定的标签，值是最终计算出的地址。

**示例 (`find_player.py`):**
```python
# 这是一个示例脚本，用于找到玩家基地址
def run(scanner):
    # 1. 找到一个静态地址作为锚点 (例如，通过AOB扫描找到访问玩家健康值的代码)
    aob_result = scanner.aob_scan("8B 0D ? ? ? ? 85 C9 74 07")
    if not aob_result:
        return None

    # 2. 从该地址读取指针
    base_ptr = scanner.read_pointer(aob_result[0] + 2) # 假设指针在指令的操作数中

    # 3. 根据偏移量计算最终地址
    player_address = scanner.read_pointer(base_ptr + 0x10) + 0x8

    return {
        "PlayerHealth": (player_address, "Player*")
    }
```

### 3.5 代码注入

代码注入功能允许您将自定义的机器码（shellcode）注入到目标进程中执行。

1.  切换到 `代码注入` 选项卡。
2.  在文本框中输入十六进制格式的shellcode。字节之间可以用空格分隔。例如: `90 90 C3` (两个 NOP 和一个 RET)。
3.  或者，点击 `从文件加载` 来加载一个包含原始字节码的二进制文件 (`.bin`)。
4.  点击 `注入并执行`。

**警告**: 代码注入是一项高级功能，不正确的shellcode可能会导致目标进程崩溃。请谨慎使用。

---

## 4. 典型工作流：查找动态血量地址

这个例子将展示如何结合使用工具的各项功能，来找到一个动态变化的玩家血量地址，并将其稳定地保存在地址表中。

1.  **识别特征**: 在游戏中找到玩家的血量值，假设当前是 100。
2.  **初步扫描**: (在其他工具如CE中) 进行数值扫描，找到血量地址。假设我们发现血量地址是 `0x12345678`。
3.  **寻找访问代码 (AOB扫描)**: 在CE中找出是哪段代码在写入这个血量地址。假设我们找到这样一条指令：`MOV [ESI+140], EAX`，并且这段代码的字节序列是 `89 86 40 01 00 00`。这是一段非常独特的指令，很可能在游戏更新后也不会改变。
4.  **创建脚本**: 在本工具中，我们创建一个新的 `find_health.py` 脚本。
    ```python
    def run(scanner):
        # 使用AOB扫描找到写入血量的代码
        code_location = scanner.aob_scan("89 86 40 01 00 00")
        if not code_location:
            return None # 如果找不到，脚本失败

        # 这段代码附近通常会有玩家对象的基地址指针
        # (这需要逆向分析，此处为简化示例)
        # 假设我们通过分析发现，玩家指针可以从另一个静态地址获取
        player_base_ptr_addr = scanner.aob_scan("A1 ? ? ? ? 8B 00") # 假设这是 MOV EAX, [StaticAddress]
        if not player_base_ptr_addr:
            return None

        player_base_ptr = scanner.read_pointer(player_base_ptr_addr[0] + 1)
        player_base = scanner.read_pointer(player_base_ptr)

        # 现在我们有了玩家基地址，血量地址就是 基地址 + 偏移量
        health_address = player_base + 0x140

        return {
            "Player Health": (health_address, "int")
        }
    ```
5.  **定义结构体 (可选但推荐)**: 在 `结构体编辑器` 中定义一个 `Player` 结构体，包含一个在偏移量 `0x140` 处的 `health` 成员 (类型为 `int`)。
6.  **修改脚本以使用结构体**: 
    ```python
    def run(scanner):
        # ... (同上，找到 player_base)
        return {
            "Player": (player_base, "Player*") # 直接返回玩家对象的基地址
        }
    ```
7.  **执行**: 在 `地址表` 选项卡中，点击 `从脚本加载`，选择 `find_health.py`。地址表现在会显示 `Player` 对象，并自动解析出 `health` 成员及其当前值。

现在，无论游戏重启多少次，只要AOB特征码和结构体偏移不变，您只需运行一次脚本，就能立即找到最新的血量地址。

## 2. 快速上手：附加到进程

1.  启动本工具 (`main.py`)。
2.  点击菜单栏的 `文件` -> `附加到进程`。
3.  在弹出的进程列表中，选择您要分析的游戏进程。
4.  点击 `附加` 按钮。

成功附加后，主窗口的标题栏将显示当前附加的进程信息，并且所有功能选项卡都将被激活。

---